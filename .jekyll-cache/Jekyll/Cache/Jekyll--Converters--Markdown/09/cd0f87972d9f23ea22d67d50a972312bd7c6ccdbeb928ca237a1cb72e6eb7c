I"“i<h1 id="descriptions-of-standardized-actions-or-triggers">Descriptions of standardized actions or triggers</h1>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#actions">Actions</a>
    <ul>
      <li><a href="#upsert-object">Upsert Object</a></li>
      <li><a href="#lookup-object-at-most-1">Lookup Object (at most 1)</a></li>
      <li><a href="#lookup-objects-plural">Lookup Objects (Plural)</a></li>
      <li><a href="#delete-object">Delete Object</a></li>
      <li><a href="#make-raw-request">Make RAW Request</a></li>
      <li><a href="#lookup-set-of-objects-by-unique-criteria">Lookup Set Of Objects By Unique Criteria</a></li>
      <li><a href="#update-object">Update Object</a></li>
      <li><a href="#create-object">Create Object</a></li>
      <li><a href="#linkingunlinking-objects">Linking/Unlinking Objects</a></li>
      <li><a href="#execute-query-or-statement-in-query-language">Execute Query or Statement in Query Language</a></li>
      <li><a href="#perform-actionevaluate-function">Perform Action/Evaluate Function</a></li>
      <li><a href="#assert-options-in-sets">Assert Option(s) in Set(s)</a></li>
      <li><a href="#merge-objects">Merge Objects</a></li>
    </ul>
  </li>
  <li><a href="#batch-actions">Batch Actions</a></li>
  <li><a href="#triggers">Triggers</a>
    <ul>
      <li><a href="#get-new-and-updated-objects-polling">Get New and Updated Objects Polling</a></li>
      <li><a href="#webhooks">Webhooks</a></li>
      <li><a href="#bulk-extract">Bulk Extract</a></li>
    </ul>
  </li>
</ul>

<p>It is important to define common rules on how an adapter responds to changes and performs actions on generic domain objects.</p>

<p>If adapters follow common behaviours, then it is possible to build integrations by combining adapters which are developed by different developers.</p>

<h2 id="actions">Actions</h2>

<h3 id="upsert-object">Upsert Object</h3>

<h5 id="example-use-case">Example Use Case</h5>

<p>I have some contact data that I want to add to my CRM.  I don‚Äôt necessarily know if there is already a contact in my CRM, so I want the connector to be smart and determine if the data needs to be matched to an existing contact or added to a new contract.</p>

<h4 id="iteration-1-upsert-object-by-id">Iteration 1: Upsert Object By ID</h4>

<h5 id="input-metadata">Input Metadata</h5>

<ul>
  <li>
    <p>One input per field in the ID that is optional.  This field is marked as being the ID.</p>
  </li>
  <li>
    <p>Inputs for other fields on the body.  All fields that are not nullable and can‚Äôt be populated by the system on create should be required.</p>
  </li>
</ul>

<h5 id="pseudo-code">Pseudo-Code</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function upsertObjectById(obj) {
  // If the object's ID is split across more than one field, we should check
  // that either all ID fields are populated or that none are.  Otherwise we
  // should throw an exception.

  const objectToUpdate = GetObjectById(obj.id);   // Usually GET verb
  if(objectToUpdate == null) {
    const createdObject = CreateObject(obj);    // Usually POST verb
    EmitData(createdObject);
  } else {
    const updatedObject = UpdateObject(obj, id);   // Usually POST/PATCH verb
    EmitData(updatedObject);
  }
}
</code></pre></div></div>

<h5 id="output-data">Output Data</h5>

<ul>
  <li>The object post creation/update as reported by the system</li>
</ul>

<h5 id="gotchas-to-lookout-for">Gotcha‚Äôs to lookout for</h5>

<ul>
  <li>
    <p>Updates should be partial updates</p>
  </li>
  <li>
    <p>Make sure to Url Encode IDs appearing in HTTP urls</p>
  </li>
</ul>

<h4 id="iteration-2-update-object-by-unique-criteria">Iteration 2: Update Object By Unique Criteria</h4>

<h5 id="input-metadata-changes">Input Metadata Changes</h5>

<ul>
  <li>
    <p>The fields that are part of the upsert criteria are marked as being part of the criteria.  If the criteria is something other than the ID, they should be marked as required.</p>

    <p>(There is a hypothetical edge case here where the system auto-populates the unique criteria)</p>
  </li>
</ul>

<h5 id="pseudo-code-1">Pseudo-Code</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function upsertObjectByUniqueCriteria(obj, uniqueCriteria) {
  // Ensure unique criteria are all populated (unless ID)
  // If criteria is th the object's ID and it is split across more than one field, we should check
  // that either all ID fields are populated or that none are.  Otherwise we
  // should throw an exception.

  const objectsToUpdate = GetObjectsByCriteria(uniqueCriteria);   // Usually GET verb
  if(objectsToUpdate.length == 0) {
    const createdObject = CreateObject(obj);    // Usually POST verb
    EmitData(createdObject);
  } else if (objectsToUpdate.length == 1) {
    const updatedObject = UpdateObject(obj, objectsToUpdate[0].id);   // Usually POST/PATCH verb
    EmitData(updatedObject);
  } else {
    throw new Error(`More than one matching object found.`);
  }
}
</code></pre></div></div>

<h3 id="lookup-object-at-most-1">Lookup Object (at most 1)</h3>
<h5 id="example-use-case-1">Example Use Case</h5>
<p>I have a contact who works for a company.  I have an ID or other distinguishing characteristic (e.g. legal name) of the company and I want to learn some detail about the company (e.g. number of employees).</p>

<h4 id="iteration-1-lookup-object-by-id">Iteration 1: Lookup Object By ID</h4>

<h5 id="input-metadata-1">Input Metadata</h5>

<ul>
  <li>One input per field in the ID.  Depending on the value of allowIdToBeOmitted this is optional or required.</li>
</ul>

<h5 id="pseudo-code-2">Pseudo-Code</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function lookupObjectById(id) {
  if(!id) {
    if(allowCriteriaToBeOmitted) {
      emitData({});
      return;
    } else {
      throw new Error('No ID provided');
    }
  }

  try {
    const foundObject = GetObjectById(id);   // Usually GET verb
    emitData(foundObject);
  } catch (NotFoundException e) {
    if(allowZeroResults) {
      emitData({});
    } else {
      throw e;
    }
  }
}
</code></pre></div></div>

<h5 id="output-data-1">Output Data</h5>

<ul>
  <li>The object as reported by the system</li>
</ul>

<h5 id="gotchas-to-lookout-for-1">Gotcha‚Äôs to lookout for</h5>

<ul>
  <li>Make sure to Url Encode IDs appearing in HTTP urls</li>
</ul>

<h5 id="not-defined-now">Not defined now</h5>

<ul>
  <li>How to handle populating linked objects.</li>
</ul>

<h4 id="iteration-2-lookup-object-by-unique-criteria">Iteration 2: Lookup Object By Unique Criteria</h4>

<h5 id="input-metadata-changes-1">Input Metadata Changes</h5>

<ul>
  <li>The input matches the selected criteria</li>
</ul>

<h5 id="pseudo-code-3">Pseudo-Code</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function lookupObjectByUniqueCriteria(uniqueCriteria) {
  if(!uniqueCriteria) {
    if(allowCriteriaToBeOmitted) {
      emitData({});
      return;
    } else {
      throw new Error('No unique criteria provided');
    }
  }

  const foundObjects = GetObjectsByCriteria(uniqueCriteria);   // Usually GET verb
  if(foundObjects.length == 0) {
    if(allowZeroResults) {
      emitData({});
    } else {
      throw new Error('Not found');
    }
  } else if (foundObjects.length ==1) {
    emitData(foundObjects[0]);
  } else {
    throw new Error('More than one object found.');
  }
}
</code></pre></div></div>

<h3 id="lookup-objects-plural">Lookup Objects (Plural)</h3>
<h5 id="example-use-case-2">Example Use Case</h5>
<p>I want to search my CRM for data based on some criteria.</p>

<h5 id="input-metadata-2">Input Metadata</h5>

<ul>
  <li>Page size: optional positive integer that defaults to 100 (only if fetch page mode)</li>
  <li>page number: required non-negative integer that is 0 based (only if fetch page mode)</li>
  <li>order: optional array of fieldname + sort direction pairs (only if fetch page mode)</li>
  <li>max result size: optional positive integer that defaults to 1000 (only if fetch all mode)</li>
  <li>For each search term:
    <ul>
      <li>fieldName</li>
      <li>fieldValue</li>
      <li>condition (equal, not equal, &gt;=, &lt;=, &gt;, &lt;, like (if supported), possibly more in the future)</li>
    </ul>
  </li>
  <li>For each search term - 1: (iteration 2)
    <ul>
      <li>criteriaLink (and/or)</li>
    </ul>
  </li>
</ul>

<h5 id="pseudo-code-4">Pseudo-Code</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function lookupObjects(criteria) {
  switch(mode) {
    case 'fetchAll':
      const results = GetObjectsByCriteria(criteria);
      if(results.length &gt;= maxResultSize) {
        throw new Error('Too many results');
      }
      emitData({results: results});
      break;
    case 'emitIndividually':
      const results = GetObjectsByCriteria(criteria);
      results.forEach(result =&gt; {
        emitData(result);
      }
      break;
    case 'fetchPage':
      const results = GetObjectsByCritieria(criteria, top: pageSize, skip: pageSize * pageNumber, orderBy: orderByTerms);
      emitData({results: results});
      break;
  }
}
</code></pre></div></div>

<h5 id="output-data-2">Output Data</h5>

<ul>
  <li>An object, with  key <code class="language-plaintext highlighter-rouge">results</code> that has an array as its value.</li>
</ul>

<h5 id="gotchas-to-lookout-for-2">Gotcha‚Äôs to lookout for</h5>

<ul>
  <li>Make sure to Url Encode field values appearing in HTTP urls</li>
</ul>

<h5 id="not-handled">Not Handled</h5>

<ul>
  <li>Order of operations in multiple terms</li>
  <li>How to get total number of matching objects</li>
</ul>

<h3 id="delete-object">Delete Object</h3>
<h5 id="example-use-case-3">Example Use Case</h5>
<p>I know the ID of a customer that I want to delete.</p>

<h4 id="iteration-1-delete-object-by-id">Iteration 1: Delete Object By ID</h4>

<h5 id="input-metadata-3">Input Metadata</h5>

<ul>
  <li>One input per field in the ID that is required.</li>
</ul>

<h5 id="pseudo-code-5">Pseudo-Code</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function deleteObjectById(id) {
  try {
    DeleteObjectById(id);   // Usually DELETE verb
  } catch (NotFoundException e) {
    emitData({});
    return;
  }
  emitData({id: id});
}
</code></pre></div></div>

<h5 id="output-data-3">Output Data</h5>

<ul>
  <li>The id of the object deleted.</li>
</ul>

<h5 id="gotchas-to-lookout-for-3">Gotcha‚Äôs to lookout for</h5>

<ul>
  <li>If zero objects are deleted, then the empty object should be emitted</li>
  <li>Make sure to Url Encode IDs appearing in HTTP urls</li>
</ul>

<h4 id="iteration-2-delete-object-by-unique-criteria">Iteration 2: Delete Object By Unique Criteria</h4>

<h5 id="input-metadata-changes-2">Input Metadata Changes</h5>

<ul>
  <li>The input matches the selected criteria</li>
</ul>

<h5 id="pseudo-code-6">Pseudo-Code</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function deleteObjectByUniqueCriteria(uniqueCriteria) {
  const foundObjects = GetObjectsByCritieria(uniqueCriteria);   // Usually GET verb
  if(foundObjects.length == 0) {
    emitData({});
  } else if (foundObjects.length == 1) {
    DeleteObjectById(foundObjects[0].id);   // Usually DELETE verb
    emitData({id: foundObjects[0].id});
  } else {
    throw new Error('More than one object found.');
  }
}
</code></pre></div></div>

<h3 id="make-raw-request">Make RAW Request</h3>

<p><em>This action has not been fully standardized.</em></p>

<p>A simple action to allow integrators to assemble requests to be sent to the system.  The component should expose the parts that vary in a typical request.  The component should handle authentication and error reporting.</p>

<h5 id="example-use-case-4">Example Use Case</h5>
<p>I‚Äôm a technically advanced user who wants to interact with a system in a way not permissible by the existing component actions but would like some simplification relative to using the REST component.</p>

<h3 id="lookup-set-of-objects-by-unique-criteria">Lookup Set Of Objects By Unique Criteria</h3>
<p>Given an array of information where each item in the array uniquely describes exactly one object.  It can be assumed that the array is short enough to reasonably fit the results in a single message.</p>

<h5 id="example-use-case-5">Example Use Case</h5>
<p>I salesperson is responsible for 0 to N accounts.  I would like to look up a piece of information for each account associated with the salesperson.</p>

<h4 id="iteration-1-lookup-object-by-id-1">Iteration 1: Lookup Object By ID</h4>
<h4 id="iteration-2-lookup-object-by-unique-criteria-1">Iteration 2: Lookup Object By Unique Criteria</h4>

<h5 id="input-metadata-4">Input Metadata</h5>

<ul>
  <li>An array where each item has one input per field in the ID.  If the ID is a single field, this input can be a simple array (as opposed to an array of objects).  Required.</li>
</ul>

<h5 id="pseudo-code-multi-field-id-case">Pseudo-Code (Multi-Field ID Case)</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function lookupSetOfObjects(itemUniqueCriteriaListToLookup) {
  const results = itemUniqueCriteriaListToLookup.map(itemUniqueCriteria =&gt; {
    const matchingItems = GetObjectsByCriteria(itemUniqueCriteria);
    if(matchingItems.length != 1) {
     throw new Error(`Lookup failed for ${itemUniqueCriteria}`);
    }
    return {
      key: itemCriteria,
      value: matchingItems[0]
    }
  })
  EmitData(results);
}
</code></pre></div></div>

<h5 id="pseudo-code-single-field-id-case-where-in-operator-is-supported">Pseudo-Code (Single-Field ID Case Where IN Operator is Supported)</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function lookupSetOfObjects(itemIdsToLookup) {
  if(itemIds.length = 0) {
    EmitData({});
    return;
  }

  const searchResults = FetchObjectsWhereIdIn(itemIdsToLookup);

  const resultDictionary = {};
  for each (let itemId of itemIdsToLookup) {
    const matchingItems = searchResults.filter(result.Id = itemId);
    if(matchingItems.length != 1) {
      throw new Error(`Lookup failed for ${itemUniqueCriteria}`);
    }
    resultDictionary[itemId] = matchingItems[0];
  }

  EmitData(resultDictionary);
}
</code></pre></div></div>

<h5 id="output-data-4">Output Data</h5>

<ul>
  <li>In the case of a single field criteria, a dictionary of the form <code class="language-plaintext highlighter-rouge">lookupCriteria: matchingItem</code></li>
  <li>In the case of multi-field criteria, an array where each item in the array has the form <code class="language-plaintext highlighter-rouge">{"key": lookupCriteria, "value": matchingItem}</code></li>
</ul>

<h5 id="gotchas-to-lookout-for-4">Gotcha‚Äôs to lookout for</h5>

<ul>
  <li>Make sure to Url Encode IDs appearing in HTTP urls</li>
</ul>

<h5 id="not-defined-now-1">Not defined now</h5>
<ul>
  <li>Encode any IDs in URLs</li>
  <li>Rebounds when an object is not found</li>
  <li>There are different structures depending on the input structure</li>
</ul>

<h3 id="update-object">Update Object</h3>

<ul>
  <li>Similar to upsert object (both iteration 1 &amp; 2) but:
    <ul>
      <li>We will not create the object if it does not exist</li>
      <li>The ID/other unique criteria is required</li>
      <li>No other fields are required</li>
    </ul>
  </li>
</ul>

<h5 id="example-use-case-6">Example Use Case</h5>
<p>I want to update the price of a product based on its SKU but I don‚Äôt want to look up other required attributes such as name since I know those have already been set and are not changing.</p>

<h3 id="create-object">Create Object</h3>

<p>Similar to upsert object but needed for the following cases:</p>

<ul>
  <li>Objects that can be created but can not be updated after creation (e.g. Invoices)</li>
  <li>Cases where you want to create an object and its children</li>
  <li>Cases where the id of the object includes information in the object (e.g. The ID of a sales line is the sales order ID + SKU).</li>
</ul>

<h5 id="example-use-case-7">Example Use Case</h5>
<p>See above.</p>

<h3 id="linkingunlinking-objects">Linking/Unlinking Objects</h3>

<ul>
  <li>Given a many-to-many relationship in a system: create/update/remove a relationship between two objects.</li>
  <li>In order to do this, the inbound metadata needs to include:
    <ul>
      <li>the types of the two objects</li>
      <li>two sets of unique criteria which describe the two objects</li>
      <li>
        <p>Information about the relationship (e.g. if assigning user to company membership, identify the role of the user)</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function linkObjects(obj1, obj2, linkMetadata) {
  const matchingObjects1 = lookupObjectByCriteria(obj1.type, obj1.uniqueCriteria);
  if (matchingObjects1.length != 1) {
    throw new Error('Not found/too many found.');
  }
  const object1Id = matchingObjects1[0].id;

  const matchingObjects2 = lookupObjectByCriteria(obj2.type, obj2.uniqueCriteria);
  if (matchingObjects2.length != 1) {
    throw new Error('Not found/too many found.');
  }
  const object2Id = matchingObjects2[0].id;

  createLink(object1Id, object2Id, linkMetadata);
}
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h5 id="example-use-case-8">Example Use Case</h5>
<p>A student can be a participant in a class and a class can have many students.  Given a student ID and a course ID I want to enroll that student in that course.</p>

<h3 id="execute-query-or-statement-in-query-language">Execute Query or Statement in Query Language</h3>
<p>Examples of this include constructing a query or statement in SQL, Salesforce‚Äôs SOQL, etc. Queries return a table of data when executed.  Statements do not reutrn results (other than execution statistics).</p>

<h5 id="example-use-case-9">Example Use Case</h5>
<p>Execute SQL query in SQL database</p>

<h5 id="input-metadata-5">Input Metadata</h5>

<ul>
  <li>For each parameterized variable in the query, there should be an input</li>
  <li>If Emit Behavior is Expect Single: a boolean input ‚ÄúAllow Zero Results‚Äù</li>
</ul>

<h5 id="pseudo-code-7">Pseudo-Code</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function executeQuery(query, params, mode, allowZeroResults) {
  const results = executeQueryOrStatementOnSystem(query, params);
  if(results is not QueryResultsTable) {
    emitData(results || {});
    return;
  }
  switch(mode) {
    case 'fetchAll':
      if(results.length &gt;= maxResultSize) {
        throw new Error('Too many results');
      }
      emitData({results: results});
      break;
    case 'emitIndividually':
      results.forEach(result =&gt; {
        emitData(result);
      }
      break;
    case 'expectSingle':
      if(results.length = 1) {
        emitData(results[0]);
      } else if(results.length = 0 &amp;&amp; allowZeroResults) {
        emitData({});
      } else {
        throw new Error('Incorrect Number of Results Found');
      }
      break;
  }
}
</code></pre></div></div>

<h5 id="output-data-5">Output Data</h5>

<ul>
  <li>If Query: Depends on mode</li>
  <li>If Statement: Execution statistics if available.  Otherwise an empty object as a result.</li>
</ul>

<h3 id="perform-actionevaluate-function">Perform Action/Evaluate Function</h3>

<p><em>This action has not been fully standardized.</em></p>

<p>Examples of this include sendEmail, calculatePrice, etc.</p>

<h3 id="assert-options-in-sets">Assert Option(s) in Set(s)</h3>
<p>Given a field which can be set to a fixed list of options, ensure that this option exists in the list of selectable options.</p>

<h5 id="example-use-case-10">Example Use Case</h5>
<p>You run a store where each product has a color.  The list of colors are finite (e.g. red, green, blue).  One day, you decide to add a new color option yellow.</p>

<h5 id="input-metadata-6">Input Metadata</h5>

<p>For each field in the object type where the populated data is a dropdown/multi-select</p>
<ul>
  <li>One input which identifies the option value that needs to be in the set. Optional</li>
  <li>Inputs for any data related to the option being added.  Not applicable for all systems
Iteration 2: Have the above receive an array</li>
</ul>

<h5 id="pseudo-code-8">Pseudo-Code</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let existingOptions = populateExistingOptions();

function assertOptionInSet(toAssert) {
  const optionsDictionary = {};

  for([field, option] of Object.entries(toAssert)) {
    let existingOption = existingOptions[field][option.value];
    if(existingOption &amp;&amp; existingOption.additionalData = option.additionalData) {
      // Nothing to do.  Publish info on the option
      optionsDictionary[field] = existingOption;
      break;
    }

    // Check for stale cached data
    existingOptions = populateExistingOptions();
    let existingOption = existingOptions[field][option.value];
    if(existingOption &amp;&amp; existingOption.additionalData = option.additionalData) {
      // Nothing to do.  Publish info on the option
      optionsDictionary[field] = existingOption;
      break;
    }

    if(!existingOption) {
      // Need to add option
      const addedOption = AddOptionToSet(field, option.value, option.additionalData);
      optionsDictionary[field] = addedOption;
    } else {
      // Need to update option
      const updatedOption = UpdateOptionInSet(field, option.value, option.additionalData);
      optionsDictionary[field] = updatedOption;
    }
  }

  EmitData(optionsDictionary);
}
</code></pre></div></div>

<h5 id="output-data-6">Output Data</h5>

<ul>
  <li>An object with all the options and associated data</li>
</ul>

<h5 id="gotchas-to-lookout-for-5">Gotcha‚Äôs to lookout for</h5>

<ul>
  <li>This action can not be run in parallel</li>
</ul>

<h3 id="merge-objects">Merge Objects</h3>

<p><em>This action has not been fully standardized.</em></p>

<p>Example: Contact merge.  There are usually two contacts, A and B with different IDs.  At the end of the merge, one ID remains with all external references to the other contact now pointing to the remaining contact.</p>

<h2 id="batch-actions">Batch Actions</h2>

<p><em>This set of actions has not been fully standardized.</em></p>

<p>It is possible to make batch variants for many of the above actions.  The batch action should perform operations which behave as the other options described above.</p>

<h2 id="triggers">Triggers</h2>

<h3 id="get-new-and-updated-objects-polling">Get New and Updated Objects Polling</h3>
<h5 id="example-use-case-11">Example Use Case</h5>
<p>I want to learn about changes to contacts in my CRM when they happen.</p>

<h5 id="input-metadata-7">Input Metadata</h5>

<p>N/A</p>

<h5 id="pseudo-code-9">Pseudo-Code</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function getObjectsPolling(cfg, snapshot) {
  const previousLastModified = snapshot.previousLastModified || cfg.startTime || new Date(0);
  const maxTime = cfg.endTime || Date.MaxDate();
  let hasMorePages = true;
  snapshot.pageNumber = snapshot.pageNumber || 0;
  let lastSeenTime = previousLastModified;
  do {
    let whereCondition;
    if (previousLastModified === cfg.startTime || new Date(0)){
      whereCondition = [
        lastModified &gt;= previousLastModified,
        lastModified &lt;= maxTime
      ];
    } else {
      whereCondition = [
        lastModified &gt; previousLastModified,
        lastModified &lt;= maxTime
      ];
    }

    const pageOfResults = GetPageOfResults({
      orderBy: Time ascending
      where: whereCondition,
      top: sizeOfPollingPage,
      skip: snapshot.pageNumber * sizeOfPollingPage
    });
    pageOfResults.forEach(result =&gt; {
      emitData(result);
    };
    snapshot.pageNumber++;
    hasMorePages = pageOfResults.length == pageSize;
    if(pageOfResults.length &gt; 0) {
      lastSeenTime = pageOfResults[pageOfResults.length - 1].lastModified;
    }
    emitSnapshot(snapshot);
    if(singlePagePerInterval &amp;&amp; hasMorePages) {
      return;
    }
  } while (hasMorePages)
  delete snapshot.pageNumber;
  snapshot.previousLastModified = lastSeenTime;
  emitSnapshot(snapshot);
}
</code></pre></div></div>

<h5 id="output-data-7">Output Data</h5>

<ul>
  <li>Each object emitted individually.</li>
</ul>

<h5 id="gotchas-to-lookout-for-6">Gotcha‚Äôs to lookout for</h5>

<ul>
  <li>If <code class="language-plaintext highlighter-rouge">previousLastModified</code> is set to <code class="language-plaintext highlighter-rouge">lastSeenTime</code> and we have <code class="language-plaintext highlighter-rouge">lastModified &gt;= previousLastModified</code> then each execution will include records from previous execution.  But if at the first execution <code class="language-plaintext highlighter-rouge">previousLastModified</code> could be equal <code class="language-plaintext highlighter-rouge">cfg.startTime</code> and we have <code class="language-plaintext highlighter-rouge">lastModified &gt; previousLastModified</code> then we will lose objects whose last modified date is equal to the <code class="language-plaintext highlighter-rouge">cfg.startTime</code>.  This is why we compare <code class="language-plaintext highlighter-rouge">previousLastModified</code> and <code class="language-plaintext highlighter-rouge">cfg.startTime || new Date(0)</code> and if they are equal, use condition <code class="language-plaintext highlighter-rouge">lastModified &gt;= previousLastModified,</code> else: <code class="language-plaintext highlighter-rouge">lastModified &gt; previousLastModified,</code></li>
  <li>We use <code class="language-plaintext highlighter-rouge">lastModified &lt;= maxTime</code> as it is more understandable for user.</li>
  <li>We have <code class="language-plaintext highlighter-rouge">Single Page per Interval</code> default to yes because it is slightly safer.</li>
  <li>TODO</li>
</ul>

<h3 id="webhooks">Webhooks</h3>

<p>Receives data pushed to the Open Integration Hub from an external system.</p>

<p>The webhook URL is being provided by the <a href="https://openintegrationhub.github.io/docs/Services/Webhooks.html">Webhook Service</a> for each flow.</p>

<h3 id="bulk-extract">Bulk Extract</h3>

<p>Useful for:</p>

<ul>
  <li>Systems that do no track last_modified</li>
  <li>Systems that don‚Äôt support filtering by timestamp range</li>
  <li>Systems which have dedicated bulk export functionality</li>
</ul>
:ET